mod config;
mod errors;
mod events;
mod outstanding_transaction;
mod result;
mod state;

#[cfg(test)]
mod tests;

pub use self::events::ClientSessionEvent;
pub use self::config::ClientSessionConfig;
pub use self::result::ClientSessionResult;
pub use self::errors::{ClientSessionError, ClientSessionErrorKind};

use self::outstanding_transaction::OutstandingTransaction;
use self::state::ClientState;
use std::collections::HashMap;
use std::time::SystemTime;
use chunk_io::{ChunkSerializer, ChunkDeserializer};
use messages::RtmpMessage;
use rml_amf0::Amf0Value;
use time::RtmpTimestamp;

type ClientResult = Result<Vec<ClientSessionResult>, ClientSessionError>;

/// A session that represents the client side of a single RTMP connection.
///
/// The `ClientSession` encapsulates the details of how a client interacts with a server.  This
/// includes how to connect to an application on the server, requesting publishing or playback,
/// and reacting to events and responses the server may send.
///
/// While RTMP connections can support multiple media operations simultanously (e.g. have 2
/// streams send video while another one pulls video) the `ClientSession` has been designed for
/// the main use case of one operation per connection.
///
/// Due to the way the header compression properties of the RTMP chunking protocol, is is required
/// that
///
/// * All bytes **after** the handshake has been completed are passed into the `ClientSession` in
/// the order they were received
/// * All responses generated by the session are sent to the server **in order**
/// * No extraneous bytes are passed into the session, and only bytes generated by the session are
/// sent to the server.
///
/// Any violation of these points have a high probability of causing RTMP chunk parsing errors
/// by either the `ClientSession` or the peer.
pub struct ClientSession {
    start_time: SystemTime,
    serializer: ChunkSerializer,
    deserializer: ChunkDeserializer,
    config: ClientSessionConfig,
    next_transaction_id: u32,
    outstanding_transactions: HashMap<u32, OutstandingTransaction>,
    current_state: ClientState,
}

impl ClientSession {
    pub fn new(config: ClientSessionConfig) -> ClientSession {
        let session = ClientSession {
            start_time: SystemTime::now(),
            serializer: ChunkSerializer::new(),
            deserializer: ChunkDeserializer::new(),
            next_transaction_id: 1,
            outstanding_transactions: HashMap::new(),
            current_state: ClientState::Disconnected,
            config,
        };

        session
    }

    pub fn handle_input(&mut self, bytes: &[u8]) -> ClientResult {
        let mut results = Vec::new();

        let mut bytes_to_process = bytes;
        loop {
            match self.deserializer.get_next_message(bytes_to_process)? {
                None => break, // no more messages
                Some(payload) => {
                    let message = payload.to_rtmp_message()?;
                    let mut message_results = match message {
                        RtmpMessage::Amf0Command {command_name, transaction_id, command_object, additional_arguments}
                            => self.handle_amf0_command(command_name, transaction_id, command_object, additional_arguments)?,

                        _ => vec![ClientSessionResult::UnhandleableMessageReceived(payload)],
                    };

                    results.append(&mut message_results);
                    bytes_to_process = &[];
                }
            }
        }

        Ok(results)
    }

    pub fn request_connection(&mut self, app_name: String) -> Result<ClientSessionResult, ClientSessionError> {
        let transaction_id = self.get_next_transaction_id();
        let transaction = OutstandingTransaction::ConnectionRequested {app_name: app_name.clone()};
        self.outstanding_transactions.insert(transaction_id as u32, transaction);

        let mut properties = HashMap::new();
        properties.insert("app".to_string(), Amf0Value::Utf8String(app_name));
        properties.insert("flashVer".to_string(), Amf0Value::Utf8String(self.config.flash_version.clone()));
        properties.insert("objectEncoding".to_string(), Amf0Value::Number(0.0));

        let message = RtmpMessage::Amf0Command {
            command_name: "connect".to_string(),
            command_object: Amf0Value::Object(properties),
            additional_arguments: vec![],
            transaction_id: transaction_id as f64,
        };

        let payload = message.into_message_payload(self.get_epoch(), 0)?;
        let packet = self.serializer.serialize(&payload, false, false)?;

        Ok(ClientSessionResult::OutboundResponse(packet))
    }

    fn handle_amf0_command(&mut self,
                           name: String,
                           transaction_id: f64,
                           command_object: Amf0Value,
                           additional_args: Vec<Amf0Value>) -> ClientResult {
        match name.as_str() {
            "_result" => self.handle_amf0_command_result(transaction_id, command_object, additional_args),

            _ => {
                let event = ClientSessionEvent::UnhandleableAmf0Command {
                    command_name: name,
                    additional_values: additional_args,
                    command_object,
                    transaction_id,
                };

                Ok(vec![ClientSessionResult::RaisedEvent(event)])
            }
        }
    }

    fn handle_amf0_command_result(&mut self,
                                  transaction_id: f64,
                                  command_object: Amf0Value,
                                  additional_args: Vec<Amf0Value>) -> ClientResult {
        let outstanding_transaction = match self.outstanding_transactions.remove(&(transaction_id as u32)) {
            Some(transaction) => transaction,
            None => {
                let event = ClientSessionEvent::UnknownTransactionResultReceived {
                    additional_values: additional_args,
                    command_object,
                    transaction_id,
                };

                return Ok(vec![ClientSessionResult::RaisedEvent(event)]);
            },
        };

        match outstanding_transaction {
            OutstandingTransaction::ConnectionRequested {app_name}
                => self.handle_connection_request_result(app_name)
        }
    }

    fn handle_connection_request_result(&mut self, app_name: String) -> ClientResult {
        self.current_state = ClientState::Connected {app_name};
        let event = ClientSessionEvent::ConnectionRequestAccepted;
        Ok(vec![ClientSessionResult::RaisedEvent(event)])
    }

    fn get_epoch(&self) -> RtmpTimestamp {
        match self.start_time.elapsed() {
            Ok(duration) => {
                let milliseconds = (duration.as_secs() * 1000) + (duration.subsec_nanos() as u64 / 1_000_000);

                // Casting to u32 should auto-wrap the value as expected.  If not a stream will probably
                // break after 49 days but testing shows it should wrap
                RtmpTimestamp::new(milliseconds as u32)
            },

            Err(_) => RtmpTimestamp::new(0), // Time went backwards, so just consider time as at epoch
        }
    }

    fn get_next_transaction_id(&mut self) -> u32 {
        let transaction_id = self.next_transaction_id;
        self.next_transaction_id += 1;
        transaction_id
    }
}